// top_module.v - Top-level integration
`timescale 1ns / 1ps

module top_module (
    input wire clk,
    input wire rst,
    input wire uart_rx_pin,
    output wire [7:0] fault_flags_leds,
    output wire uart_tx_to_mc
);

wire [9:0] temp_raw, volt_raw;
wire [7:0] fault_flags;

// Instantiate sensor simulator
sensors_sim sensor_inst (
    .clk(clk),
    .rst(rst),
    .temp_raw(temp_raw),
    .volt_raw(volt_raw)
);

// Instantiate fault detector FSM
fault_detector_fsm detector_inst (
    .clk(clk),
    .rst(rst),
    .temp(temp_raw),
    .volt(volt_raw),
    .fault_flags(fault_flags)
);

// Optional: UART wrapper to send fault flags
// Here we assume ESP32 polls via UART request-response
// For simplicity, we use a loopback-style TX

uart_loopback_tx #(.BAUD(115200)) uart_tx_inst (
    .clk(clk),
    .rst(rst),
    .trigger(1'b1), // Send every cycle (demo)
    .data_in(fault_flags),
    .uart_tx(uart_tx_to_mc)
);

// Output flags to LEDs (debug)
assign fault_flags_leds = fault_flags;

endmodule

// Simple UART transmitter (loopback-style for demo)
module uart_loopback_tx #(
    parameter CLK_FREQ = 50_000_000,
    parameter BAUD = 115200
) (
    input wire clk,
    input wire rst,
    input wire trigger,
    input wire [7:0] data_in,
    output reg uart_tx
);

localparam BIT_PERIOD = CLK_FREQ / BAUD;
reg [31:0] counter;
reg [3:0] bit_idx;
reg [7:0] shift_reg;
reg tx_active;

initial uart_tx = 1;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        uart_tx <= 1;
        counter <= 0;
        bit_idx <= 0;
        tx_active <= 0;
        shift_reg <= 0;
    end else begin
        if (trigger && !tx_active) begin
            tx_active <= 1;
            shift_reg <= data_in;
            bit_idx <= 0;
            counter <= 0;
            uart_tx <= 0; // Start bit
        end else if (tx_active) begin
            if (counter < BIT_PERIOD - 1) begin
                counter <= counter + 1;
            end else begin
                counter <= 0;
                if (bit_idx == 0 && uart_tx == 0) begin
                    uart_tx <= shift_reg[0]; // LSB first
                    bit_idx <= 1;
                end else if (bit_idx >= 1 && bit_idx <= 8) begin
                    uart_tx <= shift_reg[bit_idx];
                    bit_idx <= bit_idx + 1;
                end else begin
                    uart_tx <= 1; // Stop bit
                    tx_active <= 0;
                end
            end
        end
    end
end

endmodule